<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Digital Particle Face</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">LOADING FACE DATA...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.141.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. 기본 씬 설정
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2.5; // 카메라 거리 조절

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 성능 최적화
        document.body.appendChild(renderer.domElement);

        // 2. 쉐이더 설정 (파도 효과 + 마우스 반응)
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector3(0, 0, 0) },
                uColor: { value: new THREE.Color(0x00ffff) }, // 입자 색상 (형광 시안)
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                uniform float uTime;
                uniform vec3 uMouse;
                varying float vDist;

                // 노이즈 함수
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
                }

                void main() {
                    vec3 pos = position;

                    // A. 디지털 노이즈 웨이브 효과
                    // 입자가 제자리에서 디지털 신호처럼 떨리거나 파도침
                    float noise = sin(pos.y * 5.0 + uTime) * cos(pos.x * 5.0 + uTime) * 0.05;
                    pos += normal * noise;

                    // B. 마우스 인터랙션 (입체적인 흩어짐)
                    float dist = distance(pos.xy, uMouse.xy * 2.0); // 마우스 거리
                    float radius = 0.6; // 반응 반경
                    
                    if(dist < radius) {
                        vec3 dir = normalize(pos - vec3(uMouse.xy * 2.0, 1.0)); // 마우스 쪽에서 밀어냄
                        float force = (radius - dist) * 2.0;
                        pos += dir * force;
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 2.0 * (1.0 / -mvPosition.z); // 원근감에 따른 크기
                    gl_Position = projectionMatrix * mvPosition;

                    vDist = dist; // 프래그먼트 쉐이더로 거리 정보 전달
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vDist;

                void main() {
                    // 원형 입자 만들기
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;

                    // 마우스와 가까우면 흰색, 멀면 설정한 색상
                    vec3 finalColor = mix(vec3(1.0), uColor, step(0.1, vDist));
                    
                    // 입자의 투명도 (가장자리를 부드럽게)
                    float alpha = 1.0 - (r * 2.0);
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        // 3. 3D 모델 로드 (GLTFLoader)
        const loader = new GLTFLoader();
        let particles;

        // ★ 중요: 여기에 사용할 .glb 파일 경로를 넣으세요 ★
        // 예시용 무료 모델(LeePerrySmith) 다운로드 경로를 사용하거나 직접 파일을 넣으세요.
        // 이 코드가 작동하려면 'face.glb' 파일이 필요합니다.
        loader.load('./face.glb', function (gltf) {
            
            // 모델에서 지오메트리(형상)만 추출
            const mesh = gltf.scene.children[0]; 
            let geometry = mesh.geometry;

            // 모델을 화면 중앙으로 정렬하고 크기 조정
            geometry.center();
            geometry.scale(1.5, 1.5, 1.5); // 크기 조절

            // 파티클 시스템 생성
            particles = new THREE.Points(geometry, shaderMaterial);
            scene.add(particles);

            // 로딩 텍스트 제거
            document.getElementById('loading').style.display = 'none';

        }, undefined, function (error) {
            console.error(error);
            document.getElementById('loading').innerText = "모델을 불러오지 못했습니다 (개발자 도구 확인)";
        });

        // 4. 마우스 이벤트 및 애니메이션
        const mouse = new THREE.Vector2();
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if(particles) {
                // 부드러운 움직임을 위해 lerp 사용 가능하나 여기선 직접 대입
                shaderMaterial.uniforms.uMouse.value.x = mouse.x;
                shaderMaterial.uniforms.uMouse.value.y = mouse.y;
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            shaderMaterial.uniforms.uTime.value = time;

            if (particles) {
                // 얼굴이 천천히 회전 (마우스 위치에 따라 약간씩 기울어지게 추가 가능)
                particles.rotation.y = Math.sin(time * 0.2) * 0.1; 
                particles.rotation.x = Math.cos(time * 0.15) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        // 리사이즈 대응
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>