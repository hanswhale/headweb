<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Digital Particle Face</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-family: sans-serif; pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">LOADING FACE DATA...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.141.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. 기본 씬 설정
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // [변경됨] 얼굴이 커질 것이므로 카메라를 뒤로 조금 뺍니다 (2.5 -> 4.0)
        // 만약 더 크게 보고 싶으면 이 숫자를 줄이세요 (예: 3.5)
        camera.position.z = 4.0; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        // 2. 쉐이더 설정
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector3(0, 0, 0) },
                uColor: { value: new THREE.Color(0x00ffff) }, 
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                uniform float uTime;
                uniform vec3 uMouse;
                varying float vDist;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
                }

                void main() {
                    vec3 pos = position;

                    // 웨이브 효과
                    float noise = sin(pos.y * 5.0 + uTime) * cos(pos.x * 5.0 + uTime) * 0.05;
                    pos += normal * noise;

                    // 마우스 인터랙션
                    float dist = distance(pos.xy, uMouse.xy * 2.0); 
                    float radius = 0.6; 
                    
                    if(dist < radius) {
                        vec3 dir = normalize(pos - vec3(uMouse.xy * 2.0, 1.0)); 
                        float force = (radius - dist) * 2.0;
                        pos += dir * force;
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 2.0 * (1.0 / -mvPosition.z); 
                    gl_Position = projectionMatrix * mvPosition;

                    vDist = dist; 
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vDist;

                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;

                    vec3 finalColor = mix(vec3(1.0), uColor, step(0.1, vDist));
                    float alpha = 1.0 - (r * 2.0);
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        // 3. 3D 모델 로드
        const loader = new GLTFLoader();
        let particles;

        loader.load('./face.glb', function (gltf) {
            
            let mesh;
            gltf.scene.traverse(function (child) {
                if (child.isMesh) {
                    mesh = child;
                }
            });

            if (!mesh) {
                console.error("모델 파일에서 'Mesh' 데이터를 찾을 수 없습니다.");
                document.getElementById('loading').innerText = "모델 오류: 메쉬 데이터 없음";
                return;
            }

            let geometry = mesh.geometry;

            geometry.center();
            
            // [변경됨] 크기를 2배로 키웠습니다 (1.5 -> 3.0)
            geometry.scale(3.0, 3.0, 3.0); 

            particles = new THREE.Points(geometry, shaderMaterial);
            scene.add(particles);

            document.getElementById('loading').style.display = 'none';

        }, undefined, function (error) {
            console.error(error);
            document.getElementById('loading').innerText = "모델을 불러오지 못했습니다";
        });

        // 4. 마우스 이벤트 및 애니메이션
        const mouse = new THREE.Vector2();
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if(particles) {
                shaderMaterial.uniforms.uMouse.value.x = mouse.x;
                shaderMaterial.uniforms.uMouse.value.y = mouse.y;
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            shaderMaterial.uniforms.uTime.value = time;

            if (particles) {
                // [변경됨] 회전 속도를 더 느리게 조정했습니다.
                // 0.2 -> 0.1 (숫자가 작을수록 느려짐)
                particles.rotation.y = Math.sin(time * 0.1) * 0.1; 
                particles.rotation.x = Math.cos(time * 0.08) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>