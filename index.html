<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impact Face Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-family: sans-serif; 
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
        }
        #guide {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            color: #888; font-family: sans-serif; font-size: 14px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">데이터 로딩 시작...</div>
    <div id="guide">마우스를 움직여 회전하고, <b>화면을 클릭</b>해보세요!</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. 장면 설정 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.05);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. 배경 장식 (큐브) ---
        const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
        const cubeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x222222, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.2 
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        scene.add(cube);

        // --- 3. 전역 변수 ---
        let faceParticles; 
        let originalPositions; 
        let randomPositions;   
        let isExploded = false; 

        // --- 4. 모델 로드 (에러 처리 강화) ---
        const loader = new GLTFLoader();
        const loadingElem = document.getElementById('loading');

        // 파일 경로 설정 (현재 폴더의 face.glb)
        const modelPath = './face.glb';

        loader.load(
            modelPath, 
            function (gltf) {
                // [성공 시 실행]
                console.log("모델 로드 성공, 파티클 변환 중...");
                loadingElem.innerText = "변환 중...";

                const model = gltf.scene;
                let targetGeometry = null;

                model.traverse((child) => {
                    if (child.isMesh && targetGeometry === null) {
                        targetGeometry = child.geometry;
                    }
                });

                if (targetGeometry) {
                    targetGeometry.center();
                    
                    const count = targetGeometry.attributes.position.count;
                    originalPositions = new Float32Array(count * 3);
                    randomPositions = new Float32Array(count * 3);
                    
                    const posArray = targetGeometry.attributes.position.array;
                    for(let i = 0; i < count; i++) {
                        // 원래 좌표 저장
                        originalPositions[i*3] = posArray[i*3];
                        originalPositions[i*3+1] = posArray[i*3+1];
                        originalPositions[i*3+2] = posArray[i*3+2];

                        // 폭발 좌표 저장 (범위 확장)
                        randomPositions[i*3] = (Math.random() - 0.5) * 15; 
                        randomPositions[i*3+1] = (Math.random() - 0.5) * 15; 
                        randomPositions[i*3+2] = (Math.random() - 0.5) * 15; 
                    }

                    const particlesMaterial = new THREE.PointsMaterial({
                        color: 0x00ffff, 
                        size: 0.03,      
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });

                    faceParticles = new THREE.Points(targetGeometry, particlesMaterial);
                    
                    // ★ 크기 6배 설정
                    faceParticles.scale.set(6.0, 6.0, 6.0); 
                    
                    scene.add(faceParticles);
                    
                    // 로딩 메시지 숨기기
                    loadingElem.style.display = 'none';
                } else {
                    loadingElem.innerText = "에러: GLB 파일 안에 Mesh 데이터가 없습니다.";
                    loadingElem.style.color = "red";
                }
            },
            function (xhr) {
                // [진행 중 실행]
                if(xhr.total > 0) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    loadingElem.innerText = `다운로드 중... ${percent}%`;
                } else {
                    loadingElem.innerText = `다운로드 중... (크기 계산 불가)`;
                }
            },
            function (error) {
                // [실패 시 실행 - 화면에 에러 출력]
                console.error(error);
                loadingElem.style.color = "#ff5555"; // 빨간색
                loadingElem.innerHTML = `
                    ⚠️ <b>로딩 실패!</b><br><br>
                    파일 경로: ${modelPath}<br>
                    에러 내용: ${error.message || "파일을 찾을 수 없습니다 (404)"}<br><br>
                    <small>깃허브 저장소에 <b>face.glb</b>가 업로드되었는지,<br>
                    파일명이 소문자인지 확인해주세요.</small>
                `;
            }
        );

        camera.position.z = 8;

        // --- 5. 이벤트 리스너 ---
        let mouseX = 0; 
        let mouseY = 0;
        let targetRotateX = 0; 
        let targetRotateY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });

        document.addEventListener('click', () => {
            isExploded = !isExploded; 
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 6. 애니메이션 ---
        function animate() {
            requestAnimationFrame(animate);

            targetRotateX = mouseX * 0.0005;
            targetRotateY = mouseY * 0.0005;

            cube.rotation.y += 0.002;

            if (faceParticles) {
                // 회전 반응
                faceParticles.rotation.y += 0.05 * (targetRotateX - faceParticles.rotation.y);
                faceParticles.rotation.x += 0.05 * (targetRotateY - faceParticles.rotation.x);

                const positions = faceParticles.geometry.attributes.position.array;
                
                // 파티클 이동 (Lerp)
                for(let i = 0; i < positions.length / 3; i++) {
                    const ix = i * 3;
                    const iy = i * 3 + 1;
                    const iz = i * 3 + 2;

                    let targetX, targetY, targetZ;

                    if (isExploded) {
                        targetX = randomPositions[ix];
                        targetY = randomPositions[iy];
                        targetZ = randomPositions[iz];
                    } else {
                        targetX = originalPositions[ix];
                        targetY = originalPositions[iy];
                        targetZ = originalPositions[iz];
                    }

                    positions[ix] += (targetX - positions[ix]) * 0.08; // 속도 약간 빠름
                    positions[iy] += (targetY - positions[iy]) * 0.08;
                    positions[iz] += (targetZ - positions[iz]) * 0.08;
                }
                
                faceParticles.geometry.attributes.position.needsUpdate = true;
                
                // 색상 변경 효과
                if(isExploded) {
                    faceParticles.material.color.lerp(new THREE.Color(0xff00ff), 0.05); 
                } else {
                    faceParticles.material.color.lerp(new THREE.Color(0x00ffff), 0.05); 
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>